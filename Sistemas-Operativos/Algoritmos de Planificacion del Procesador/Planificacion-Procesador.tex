\documentclass{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{courier}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{blindtext}
\usepackage{scrextend}
\usepackage[document]{ragged2e}
\usepackage{multicol}
\usepackage{pgfgantt}
\usepackage{minted}
\usepackage{tikz}
\usepackage{longtable}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsmath}
\usepackage{wrapfig,lipsum,booktabs}
 % % % % % % % %

\hypersetup{
	colorlinks,
	linkcolor={blue!60!black},
	citecolor={blue!50!black},
	urlcolor={blue!80!black}
}

\usetikzlibrary{positioning,fit,calc}

\usemintedstyle{pastie}

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\def\labelitemi{\textbf{--}}

\usepackage{anysize}
\marginsize{2.54cm}{2.54cm}{2.54cm}{2.54cm}

\usepackage{setspace}
%\onehalfspacing
\doublespacing

\makeatletter
\newcommand*{\MoveFitHeight}[1]{%
	\pgfmathsetlengthmacro\fit@inner@sep{%
		\pgfkeysvalueof{/pgf/inner xsep}%
	}%
	\pgfmathsetlengthmacro\fit@text@height{%
		\tikz@text@height
	}%
	\kern-\fit@inner@sep\relax
	\raisebox{\fit@text@height}[0pt][0pt]{#1}%
}
\makeatother

\setlength{\columnsep}{1cm}

%En caso de que LaTeX separe las palabras con - de manera incorrecta, usar
%\hyphenation{deci-sión,e-xa-men, otras palabras....}

% %PORTADA
\begin{document}
\title{Algoritmos de Planificación del Procesador}
\author{Victor Tortolero}

\centerline{Universidad de Carabobo}
\centerline{Facultad de Ciencia y Tecnologia}
\centerline{Sistemas Operativos}

\vspace{8cm}
\begin{centering}
\hrule 	\vspace{0.4cm}
	{ \Huge \bfseries Algoritmos de Planificación del Procesador \\[0.4cm] }
\hrule \vfill
\end{centering}

\vfill
\centerline{Victor Tortolero, 24.569.609}


\centerline{\today}

\newpage
% %Fin Portada


\flushleft
\setlength{\parindent}{20pt}


%%CUERPO PRINCIPAl%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
\justify

% First Come First Serve (FCFS) %---------------------------------------------
{\centering \section{First Come First Serve (FCFS)}}

Con este algoritmo los procesos se van ingresando en una cola FIFO(First In, First Out), 
al llegar el proceso se inserta su PCB en la cola, luego si el CPU esta libre toma el primer
elemento de la cola y se elimina este de la cola. Como es no apropiativo, la CPU solo toma
otro proceso de la cola al terminar el actual.

Para implantar este algoritmo solo se requiere una cola FIFO.

\begin{itemize}
	\item \textbf{Ventajas}
	\begin{itemize}
			\item Es fácil de entender e implementar.
			\item Aunque normalmente es justo en como dedica tiempo de CPU a los procesos,
			los procesos largos hacen esperar a los cortos.
	\end{itemize}

	\item \textbf{Desventajas}
	\begin{itemize}
		\item El tiempo de espera es alto por lo que carece de rendimiento.
		\item No apropiativo.
	\end{itemize}
\end{itemize}

Supongamos que tenemos 3 procesos:
\begin{center}
\begin{tabular}{c|c}
	Proceso & Tiempo de Ráfaga \\ \hline
	$P_{0}$ & 20 \\ \hline
	$P_{1}$ & 6 \\ \hline
	$P_{2}$ & 9 \\ \hline
\end{tabular}
\end{center}

Si los procesos llegan en el siguiente orden, $P_{0} \rightarrow P_{1} \rightarrow P_{2}$, tendríamos el diagrama de gantt \ref{gantt:FCFS1},
y el tiempo de espera promedio seria $\frac{0 + 20 + 26}{3} = 15.333$. \newline
En cambio si los procesos llegaran en el orden $P_{1} \rightarrow P_{2} \rightarrow P_{0}$, tendríamos el diagrama de gantt \ref{gantt:FCFS2},
y el tiempo de espera promedio seria $\frac{0 + 6 + 15}{3} = 8$. \newline
En este algoritmo es importante el orden en el que llegan los procesos, y si el tiempo entre ellos varia de gran manera, entonces tendremos
un tiempo de espera alto.

\vspace{0.4cm}

\begin{figure}[h]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[box/.style={draw,minimum width=2cm, minimum height=1cm,align=center}, node distance=0cm and 0cm]
		\node[box, minimum width=4cm] (N1) {$P_{0}$};
		\node[box, minimum width=0.6cm, right=of N1] (N2) {$P_{1}$};
		\node[box, minimum width=1cm, right=of N2] (N3) {$P_{2}$};
		\node[dashed, inner sep=2pt, fit={(N1) (N2)}, align=left,] (fit) {\MoveFitHeight{0}};
		\node[dashed, inner sep=2pt, fit={(N2) (N3)}, align=left,] (fit) {\MoveFitHeight{20}};
		\node[dashed, inner sep=2pt, fit={(N3) (N3)}, align=left,] (fit) {\MoveFitHeight{26}};
		\node[dashed, inner sep=2pt, fit={(N3) (N3)}, align=right,] (fit) {\MoveFitHeight{35}};
		\end{tikzpicture}
		\caption{FCFS, Ejemplo 1}
		\label{gantt:FCFS1}
	\end{minipage}\hfill
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[box/.style={draw,minimum width=2cm, minimum height=1cm,align=center}, node distance=0cm and 0cm]
		\node[box, minimum width=0.6cm] (N1) {$P_{1}$};
		\node[box, minimum width=1cm, right=of N1] (N2) {$P_{2}$};
		\node[box, minimum width=4cm, right=of N2] (N3) {$P_{0}$};
		\node[dashed, inner sep=2pt, fit={(N1) (N2)}, align=left,] (fit) {\MoveFitHeight{0}};
		\node[dashed, inner sep=2pt, fit={(N2) (N3)}, align=left,] (fit) {\MoveFitHeight{6}};
		\node[dashed, inner sep=2pt, fit={(N3) (N3)}, align=left,] (fit) {\MoveFitHeight{15}};
		\node[dashed, inner sep=2pt, fit={(N3) (N3)}, align=right,] (fit) {\MoveFitHeight{35}};
		\end{tikzpicture}
		\caption{FCFS, Ejemplo 2}
		\label{gantt:FCFS2}
	\end{minipage}
\end{figure}
\newpage
%----------------------------------------------------------------------------------%


% Shortest Job First (SJF) %---------------------------------------------
{\centering \section{Shortest Job First (SJF)}}

Este algoritmo selecciona el proceso con el próximo tiempo de ejecución mas corto.
Asocia con cada proceso la duración de la siguiente ráfaga de CPU del proceso.
Cuando el CPU esta libre se le asigna el proceso que tiene la siguiente ráfaga de CPU
mas corta. Si varios procesos tienen la misma duración de ráfaga, se usa el algoritmo
FCFS para elegir el proceso.

Para implantar este algoritmo se requiere una cola, y una manera de saber la duracion de la siguiente ráfaga
de CPU para los procesos en la cola, normalmente se usan métodos para hacer aproximaciones.
\begin{itemize}
	\item \textbf{Ventajas}
	\begin{itemize}
		\item S
	\end{itemize}
	
	\item \textbf{Desventajas}
	\begin{itemize}
		\item Difícil de implementar ya que es complicado conocer la duración de la siguiente ráfaga
		de CPU para un proceso.
	\end{itemize}
\end{itemize}

Supongamos que tenemos 4 procesos:
\begin{center}
	\begin{tabular}{c|c|c}
		Proceso & Tiempo de Ráfaga(ms) & Tiempo de llegada(ms) \\ \hline
		$P_{0}$ & 20 & 3 \\ \hline
		$P_{1}$ & 6 & 2 \\ \hline
		$P_{2}$ & 24 & 0 \\ \hline
		$P_{3}$ & 8 & 1 \\
	\end{tabular}
\end{center}

Primero el CPU trataría el $P_{2}$ ya que es el primero en entrar a la cola,
luego cuando llega el $P_{3}$ el algoritmo verifica y tenemos que el tiempo que le queda
a $P_{2}$(23ms) es mayor al tiempo que le queda a $P_{3}$(8ms), por lo que el CPU trata a $P_{3}$.
Siguiendo estas reglas tendríamos el diagrama de gantt \ref{gantt:SJF1}.

\vspace{0.4cm}

\begin{figure}[h]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[box/.style={draw,minimum width=2cm, minimum height=1cm,align=center}, node distance=0cm and 0cm]
			\node[box, minimum width=1cm] (N1) {$P_{2}$};
			\node[box, minimum width=1cm, right=of N1] (N2) {$P_{3}$};
			\node[box, minimum width=1.8cm, right=of N2] (N3) {$P_{1}$};
			\node[box, minimum width=1.5cm, right=of N3] (N4) {$P_{3}$};
			\node[box, minimum width=1.5cm, right=of N4] (N5) {$P_{4}$};
			\node[box, minimum width=1.5cm, right=of N5] (N6) {$P_{2}$};
			\node[, dashed, inner sep=2pt, fit={(N1) (N2)}, align=left,] (fit) {\MoveFitHeight{0}};
			\node[, dashed, inner sep=2pt, fit={(N2) (N3)}, align=left,] (fit) {\MoveFitHeight{1}};
			\node[, dashed, inner sep=2pt, fit={(N3) (N4)}, align=left,] (fit) {\MoveFitHeight{2}};
			\node[, dashed, inner sep=2pt, fit={(N4) (N5)}, align=left,] (fit) {\MoveFitHeight{8}};
			\node[, dashed, inner sep=2pt, fit={(N5) (N6)}, align=left,] (fit) {\MoveFitHeight{15}};
			\node[, dashed, inner sep=2pt, fit={(N6) (N6)}, align=left,] (fit) {\MoveFitHeight{35}};
			\node[, dashed, inner sep=2pt, fit={(N6) (N6)}, align=right,] (fit) {\MoveFitHeight{58}};
		\end{tikzpicture}
		\caption{SJF, Ejemplo 1}
		\label{gantt:SJF1}
	\end{minipage}\hfill
\end{figure}
\newpage
%----------------------------------------------------------------------------------%


% Short Remaining Time First (SRTF) %----------------------------------------------%
{\centering \section{Short Remaining Time First (SRTF)}}

Este algoritmo selecciona el proceso que esta en ejecución con otro que exija menor tiempo de ejecución.
Consigue una buena eficiencia, ya que logra que la lista de procesos preparados sea lo más corta posible. 

\begin{itemize}
	\item \textbf{Ventajas}
	\begin{itemize}
		\item Es apropiativo, y eficiente.
		\item Presenta un buen tiempo promedio de servicio.
	\end{itemize}
	
	\item \textbf{Desventajas}
	\begin{itemize}
		\item Los procesos largos no se ejecutaran mientras existan procesos cortos 
		en la cola.
	\end{itemize}
\end{itemize}

Supongamos que tenemos 4 procesos:
\begin{center}
	\begin{tabular}{c|c|c}
		Proceso & Tiempo de Ráfaga(ms) & Tiempo de llegada(ms) \\ \hline
		$P_{0}$ & 20 & 3 \\ \hline
		$P_{1}$ & 6 & 2 \\ \hline
		$P_{2}$ & 24 & 0 \\ \hline
		$P_{3}$ & 8 & 1 \\
	\end{tabular}
\end{center}

Primero el CPU trataría el $P_{2}$ ya que es el primero en entrar a la cola,
luego cuando llega el $P_{3}$ el algoritmo verifica y tenemos que el tiempo que le queda
a $P_{2}$(23ms) es mayor al tiempo que le queda a $P_{3}$(8ms), por lo que el CPU trata a $P_{3}$.
Siguiendo estas reglas tendríamos el diagrama de gantt \ref{gantt:SJF1}.

\vspace{0.4cm}

\begin{figure}[h]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[box/.style={draw,minimum width=2cm, minimum height=1cm,align=center}, node distance=0cm and 0cm]
		\node[box, minimum width=1cm] (N1) {$P_{2}$};
		\node[box, minimum width=1cm, right=of N1] (N2) {$P_{3}$};
		\node[box, minimum width=1.8cm, right=of N2] (N3) {$P_{1}$};
		\node[box, minimum width=1.5cm, right=of N3] (N4) {$P_{3}$};
		\node[box, minimum width=1.5cm, right=of N4] (N5) {$P_{4}$};
		\node[box, minimum width=1.5cm, right=of N5] (N6) {$P_{2}$};
		\node[dashed, inner sep=2pt, fit={(N1) (N2)}, align=left,] (fit) {\MoveFitHeight{0}};
		\node[dashed, inner sep=2pt, fit={(N2) (N3)}, align=left,] (fit) {\MoveFitHeight{1}};
		\node[dashed, inner sep=2pt, fit={(N3) (N4)}, align=left,] (fit) {\MoveFitHeight{2}};
		\node[dashed, inner sep=2pt, fit={(N4) (N5)}, align=left,] (fit) {\MoveFitHeight{8}};
		\node[dashed, inner sep=2pt, fit={(N5) (N6)}, align=left,] (fit) {\MoveFitHeight{15}};
		\node[dashed, inner sep=2pt, fit={(N6) (N6)}, align=left,] (fit) {\MoveFitHeight{35}};
		\node[dashed, inner sep=2pt, fit={(N6) (N6)}, align=right,] (fit) {\MoveFitHeight{58}};
		\end{tikzpicture}
		\caption{SJF, Ejemplo 1}
		\label{gantt:SJF1}
	\end{minipage}\hfill
\end{figure}
\newpage
%----------------------------------------------------------------------------------%


% Round Robin (RR) %---------------------------------------------------------------%
{\centering \section{Round Robin (RR)}}

Consiste en conceder a cada proceso en ejecución un determinado período de tiempo, denominado quantum (Q), transcurrido el cual,
si el proceso no ha terminado, se le devuelve al final de la cola de procesos preparados y se pasa al proceso
que este de primero en la cola.
Esta interrupción periódica continúa hasta que el proceso termine su ejecución, formando una rueda de procesos que 
serán ejecutados cíclicamente hasta que terminen.

Para su implantación requiere una cola y el valor optimo de Q, el cual se determina según
el tipo de sistema y el numero de procesos.

\begin{itemize}
	\item \textbf{Ventajas}
	\begin{itemize}
		\item Es justo con todos los procesos.
		\item Es apropiativo.
	\end{itemize}
	
	\item \textbf{Desventajas}
	\begin{itemize}
		\item Si el valor de Q es mayor que el tiempo requerido 
		por el proceso mas largo, se convierte en FCFS.
		\item Si el valor de Q es muy pequeño se producen muchos
		cambios de contexto lo que es ineficiente.
	\end{itemize}
\end{itemize}

Supongamos que tenemos 3 procesos:
\begin{center}
	\begin{tabular}{c|c|c}
		Proceso & Tiempo de Ráfaga(ms) & Tiempo de llegada(ms) \\ \hline
		$P_{0}$ & 5 & 0 \\ \hline
		$P_{1}$ & 3 & 1 \\ \hline
		$P_{2}$ & 8 & 2 \\ \hline
	\end{tabular}
\end{center}

Para Q = 4,  y Q = 8 tenemos:

\vspace{0.4cm}

\begin{figure}[h]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[box/.style={draw,minimum width=2cm, minimum height=1cm,align=center}, node distance=0cm and 0cm]
		\node[box, minimum width=1.2cm] (N1) {$P_{0}$};
		\node[box, minimum width=0.9cm, right=of N1] (N2) {$P_{1}$};
		\node[box, minimum width=1.2cm, right=of N2] (N3) {$P_{2}$};
		\node[box, minimum width=0.6cm, right=of N3] (N4) {$P_{1}$};
		\node[box, minimum width=1.2cm, right=of N4] (N5) {$P_{2}$};
		\node[dashed, inner sep=2pt, fit={(N1) (N2)}, align=left,] (fit) {\MoveFitHeight{0}};
		\node[dashed, inner sep=2pt, fit={(N2) (N3)}, align=left,] (fit) {\MoveFitHeight{4}};
		\node[dashed, inner sep=2pt, fit={(N3) (N4)}, align=left,] (fit) {\MoveFitHeight{7}};
		\node[dashed, inner sep=2pt, fit={(N4) (N5)}, align=left,] (fit) {\MoveFitHeight{11}};
		\node[dashed, inner sep=2pt, fit={(N5) (N5)}, align=left,] (fit) {\MoveFitHeight{12}};
		\node[dashed, inner sep=2pt, fit={(N5) (N5)}, align=right,] (fit) {\MoveFitHeight{16}};
		\end{tikzpicture}
		\caption{RR, Q = 4}
		\label{gantt:RR1}
	\end{minipage}\hfill
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[box/.style={draw,minimum width=2cm, minimum height=1cm,align=center}, node distance=0cm and 0cm]
		\node[box, minimum width=1.2cm] (N1) {$P_{0}$};
		\node[box, minimum width=0.9cm, right=of N1] (N2) {$P_{1}$};
		\node[box, minimum width=1.2cm, right=of N2] (N3) {$P_{2}$};
		\node[dashed, inner sep=2pt, fit={(N1) (N2)}, align=left,] (fit) {\MoveFitHeight{0}};
		\node[dashed, inner sep=2pt, fit={(N2) (N3)}, align=left,] (fit) {\MoveFitHeight{5}};
		\node[dashed, inner sep=2pt, fit={(N3) (N3)}, align=left,] (fit) {\MoveFitHeight{8}};
		\node[dashed, inner sep=2pt, fit={(N3) (N3)}, align=right,] (fit) {\MoveFitHeight{16}};
		\end{tikzpicture}
		\caption{RR, Q = 8}
		\label{gantt:RR2}
	\end{minipage}\hfill
\end{figure}
\newpage
%----------------------------------------------------------------------------------%


%--% Prioridades %-----------------------------------------------------------------%
{\centering \section{Prioridades}}

Se asocia a cada proceso un numero de prioridad (mientras menor sea el número, mas alta la prioridad).
Las prioridades pueden ser definidas interna o externamente.
En el primer caso, el sistema operativo se basa en una serie de informaciones medibles para el cálculo 
y asignación de dichas prioridades (tiempo necesitado de procesador, necesidad de memoria, etc.). 
Los factores externos son asignados por otro programa o el usuario.
Si hay varios procesos con la misma prioridad, se resuelve con FCFS.

Para su implantación se necesita una cola de prioridades, indicar si las prioridades
se definirán de manera interna o externa y la razón de incremento si se usa
envejecimiento.

\begin{itemize}
	\item \textbf{Ventajas}
	\begin{itemize}
		\item Puede ser apropiativo o no apropiativo.
	\end{itemize}
	
	\item \textbf{Desventajas}
	\begin{itemize}
		\item Si no se usa envejecimiento, un proceso con muy baja prioridad puede llegar
		a no ejecutarse nunca.
	\end{itemize}
\end{itemize}

Supongamos que tenemos 3 procesos:
\begin{center}
	\begin{tabular}{|c|c|c|c|} \hline
		Proceso & Tiempo de Ráfaga(ms) & Tiempo de llegada(ms) & Prioridad \\ \hline
		$P_{0}$ & 5 & 0 & 3 \\ 
		$P_{1}$ & 3 & 1 & 1 \\ 
		$P_{2}$ & 8 & 2 & 2 \\ \hline
	\end{tabular}
\end{center}

Tenemos el primer ejemplo sin envejecimiento, y el segundo ejemplo con 
envejecimiento T = 2 (Cada 2ms la prioridad disminuye en 1).

\vspace{0.4cm}

\begin{figure}[h]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[box/.style={draw,minimum width=2cm, minimum height=1cm,align=center}, node distance=0cm and 0cm]
		\node[box, minimum width=0.6cm] (N1) {$P_{0}$};
		\node[box, minimum width=0.9cm, right=of N1] (N2) {$P_{1}$};
		\node[box, minimum width=1.6cm, right=of N2] (N3) {$P_{2}$};
		\node[box, minimum width=1.1cm, right=of N3] (N4) {$P_{0}$};
		\node[dashed, inner sep=2pt, fit={(N1) (N2)}, align=left,] (fit) {\MoveFitHeight{0}};
		\node[dashed, inner sep=2pt, fit={(N2) (N3)}, align=left,] (fit) {\MoveFitHeight{1}};
		\node[dashed, inner sep=2pt, fit={(N3) (N4)}, align=left,] (fit) {\MoveFitHeight{4}};
		\node[dashed, inner sep=4pt, fit={(N4) (N4)}, align=left,] (fit) {\MoveFitHeight{12}};
		\node[dashed, inner sep=2pt, fit={(N4) (N4)}, align=right,] (fit) {\MoveFitHeight{16}};
		\end{tikzpicture}
		\caption{Prioridades, Sin envejecimiento}
		\label{gantt:Prioridades1}
	\end{minipage}\hfill
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[box/.style={draw,minimum width=2cm, minimum height=1cm,align=center}, node distance=0cm and 0cm]
		\node[box, minimum width=0.6cm] (N1) {$P_{0}$};
		\node[box, minimum width=0.9cm, right=of N1] (N2) {$P_{1}$};
		\node[box, minimum width=1.1cm, right=of N2] (N3) {$P_{0}$};
		\node[box, minimum width=1.6cm, right=of N3] (N4) {$P_{2}$};
		\node[dashed, inner sep=2pt, fit={(N1) (N2)}, align=left,] (fit) {\MoveFitHeight{0}};
		\node[dashed, inner sep=2pt, fit={(N2) (N3)}, align=left,] (fit) {\MoveFitHeight{1}};
		\node[dashed, inner sep=2pt, fit={(N3) (N4)}, align=left,] (fit) {\MoveFitHeight{4}};
		\node[dashed, inner sep=4pt, fit={(N4) (N4)}, align=left,] (fit) {\MoveFitHeight{8}};
		\node[dashed, inner sep=2pt, fit={(N4) (N4)}, align=right,] (fit) {\MoveFitHeight{16}};
		\end{tikzpicture}
		\caption{Prioridades, Envejecimiento T=2}
		\label{gantt:Prioridades2}
	\end{minipage}\hfill
\end{figure}
\newpage
%----------------------------------------------------------------------------------%


%--% Colas Multinivel %-----------------------------------------------------------------%
{\centering \section{Colas Multinivel}}

Con este algoritmo los procesos se agrupan y se asignan a diferentes colas,
cada cola puede tener su propio algoritmo de planificación. Para elegir que cola usar,
se puede usar un algoritmo de prioridades sin envejecimiento, o asignar un porcentaje
de tiempo para cada cola.
Cada proceso se inserta en una cola y permanece en ella.
\begin{itemize}
	\item \textbf{Ventajas}
	\begin{itemize}
		\item Es apropiativo.
		\item Es muy adaptable a las necesidades del sistema, ya que cada cola puede ser gestionada de
		forma diferente.

	\end{itemize}
	
	\item \textbf{Desventajas}
	\begin{itemize}
		\item Si no se usa envejecimiento, un proceso con muy baja prioridad puede llegar
		a no ejecutarse nunca.
	\end{itemize}
\end{itemize}

Supongamos que tenemos 3 procesos:
\begin{center}
	\begin{tabular}{|c|c|c|c|} \hline
		Proceso & Tiempo de Ráfaga(ms) & Tiempo de llegada(ms) & Prioridad \\ \hline
		$P_{0}$ & 5 & 0 & 3 \\ 
		$P_{1}$ & 3 & 1 & 1 \\ 
		$P_{2}$ & 8 & 2 & 2 \\ \hline
	\end{tabular}
\end{center}

Tenemos el primer ejemplo sin envejecimiento, y el segundo ejemplo con 
envejecimiento T = 2 (Cada 2ms la prioridad disminuye en 1).

\vspace{0.4cm}

\begin{figure}[h]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[box/.style={draw,minimum width=2cm, minimum height=1cm,align=center}, node distance=0cm and 0cm]
		\node[box, minimum width=0.6cm] (N1) {$P_{0}$};
		\node[box, minimum width=0.9cm, right=of N1] (N2) {$P_{1}$};
		\node[box, minimum width=1.6cm, right=of N2] (N3) {$P_{2}$};
		\node[box, minimum width=1.1cm, right=of N3] (N4) {$P_{0}$};
		\node[dashed, inner sep=2pt, fit={(N1) (N2)}, align=left,] (fit) {\MoveFitHeight{0}};
		\node[dashed, inner sep=2pt, fit={(N2) (N3)}, align=left,] (fit) {\MoveFitHeight{1}};
		\node[dashed, inner sep=2pt, fit={(N3) (N4)}, align=left,] (fit) {\MoveFitHeight{4}};
		\node[dashed, inner sep=4pt, fit={(N4) (N4)}, align=left,] (fit) {\MoveFitHeight{12}};
		\node[dashed, inner sep=2pt, fit={(N4) (N4)}, align=right,] (fit) {\MoveFitHeight{16}};
		\end{tikzpicture}
		\caption{Prioridades, Sin envejecimiento}
		\label{gantt:Prioridades1}
	\end{minipage}\hfill
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[box/.style={draw,minimum width=2cm, minimum height=1cm,align=center}, node distance=0cm and 0cm]
		\node[box, minimum width=0.6cm] (N1) {$P_{0}$};
		\node[box, minimum width=0.9cm, right=of N1] (N2) {$P_{1}$};
		\node[box, minimum width=1.1cm, right=of N2] (N3) {$P_{0}$};
		\node[box, minimum width=1.6cm, right=of N3] (N4) {$P_{2}$};
		\node[dashed, inner sep=2pt, fit={(N1) (N2)}, align=left,] (fit) {\MoveFitHeight{0}};
		\node[dashed, inner sep=2pt, fit={(N2) (N3)}, align=left,] (fit) {\MoveFitHeight{1}};
		\node[dashed, inner sep=2pt, fit={(N3) (N4)}, align=left,] (fit) {\MoveFitHeight{4}};
		\node[dashed, inner sep=4pt, fit={(N4) (N4)}, align=left,] (fit) {\MoveFitHeight{8}};
		\node[dashed, inner sep=2pt, fit={(N4) (N4)}, align=right,] (fit) {\MoveFitHeight{16}};
		\end{tikzpicture}
		\caption{Prioridades, Envejecimiento T=2}
		\label{gantt:Prioridades2}
	\end{minipage}\hfill
\end{figure}
\newpage
%----------------------------------------------------------------------------------%


% Sistemas de Tiempo Real %--------------------------------------------------------%
\section*{Sistemas de Tiempo Real}
Es un sistema en el que se requiere no solo que los resultados calculados sean correctos,
sino que también se produzcan dentro de un periodo de tiempo especificado.
%----------------------------------------------------------------------------------%


%%FIN CUERPO PRINCIPAl%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section*{Glosario}
\begin{itemize}
	\item \textbf{Ráfaga CPU}: Tiempo de ejecución en CPU entre dos E/S.
	\item \textbf{Ráfaga E/S}: Tiempo entre solicitud y terminación de E/S.
\end{itemize}


% Bibliografia
\cite{pag1, intef, jaume, Silberschatz}

\newpage

\bibliographystyle{unsrt}
\bibliography{bibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
